package morph.compiler

import com.google.auto.common.MoreElements
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import me.eugeniomarletti.kotlin.metadata.visibility
import com.ltrojanowski.morph.api.MorphBuilder
import javax.lang.model.element.TypeElement

data class MorphTargetsAndSources(val target: TypeElement, val sources: List<TypeElement>)

fun ValidatedContext.generateMorphExtensions(): FileSpec {

    val packageName = MoreElements.getPackage(target.element).toString()
    val targetBuilderName = "${target.element.simpleName}MorphBuilder"
    val targetTypeParams = target.classData.typeParameterList
            .map { it.getGenericTypeName(target.nameResolver, target.classData::getTypeParameter) }
    val targetElementType = target.element.asClassName().let {
        if (targetTypeParams.isNotEmpty()) {
            it.parameterizedBy(*(targetTypeParams.toTypedArray()))
        } else {
            it
        }
    }
    val targetVisibility = target.classData.visibility?.asKModifier()
    val targetTypeNameByName = this.target.typeNames
    val targetBuilderParameterSpecs =
            targetTypeNameByName
                    .map { (name, typeName) ->
                        ParameterSpec.builder(name, typeName.copy(nullable = true)).build()
                    }
    val targetBuilderPropertySpecs =
            targetTypeNameByName
                    .map { (name, typeName) ->
                        PropertySpec.builder(name, typeName.copy(nullable = true))
                                .initializer(name)
                                .mutable()
                                .build()
                    }

    val targetKClass = target.element.asType().asTypeName()

    val targetBuilderClass = TypeSpec.classBuilder(targetBuilderName)
            .addSuperinterface(MorphBuilder::class.asTypeName().parameterizedBy(targetKClass))
            .primaryConstructor(
                    FunSpec.constructorBuilder()
                            .addParameters(targetBuilderParameterSpecs)
                            .build()
            )
            .addProperties(targetBuilderPropertySpecs)
            .addFunction(
                    FunSpec.builder("morph")
                            .addModifiers(KModifier.OVERRIDE)
                            .addStatement("return %T(${targetTypeNameByName
                                    .map { (k, v) -> if (v.isNullable) "$k = $k" else "$k = $k!!" }.joinToString()})",
                                    targetKClass)
                            .returns(targetKClass)
                            .build()
            )
            .build()

    val unitTypeName = Unit::class.asTypeName()

    val intoFunctions = sources.map { source ->

        val sourceKClass = source.element.asType().asTypeName()

        val jvmNameAnnotation =
                AnnotationSpec.builder(JvmName::class)
                        .addMember("name = %S", "into${target.element.simpleName}From${source.element.simpleName}")
                        .build()

        FunSpec.builder("into")
                .addModifiers(KModifier.INLINE)
                .receiver(sourceKClass)
                .addTypeVariable(TypeVariableName(target.element.simpleName.toString()))
                .addParameter(
                        "block",
                        LambdaTypeName.get(receiver = ClassName.bestGuess(targetBuilderClass.name!!),
                                returnType = unitTypeName))
                .returns(ClassName.bestGuess(targetBuilderClass.name!!))
                .addStatement("return %T(${
                    target.typeNames.keys.map { key ->
                        if (source.typeNames.get(key) == null) { "null" } else { "this.$key" }
                    }.joinToString()
                }).apply(block)", ClassName.bestGuess(targetBuilderClass.name!!))
                .build()
    }


    val targetFile = FileSpec.builder(packageName, "${target.element.simpleName}MorphExtensions")
            .addComment("Generated by morph. Do not edit.")
            .addType(targetBuilderClass)

    val kotlinFile = intoFunctions.fold(targetFile) { builder, funSpec -> builder.addFunction(funSpec) }.build()

    return kotlinFile
}